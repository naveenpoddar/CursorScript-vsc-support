const fs = require("fs");
const path = require("path");

// Paths to the engine source
const libDir = path.join(__dirname, "..", "CursorPP", "src", "lib");
const envFile = path.join(
  __dirname,
  "..",
  "CursorPP",
  "src",
  "runtime",
  "environment.ts",
);

// Mapping for library names
const libMap = {
  "MathLib.ts": "Math",
  "JSONLib.ts": "Json",
  "StringLib.ts": "String",
  "FileLib.ts": "File",
  "AudioLib.ts": "Audio",
  "DateTimeLib.ts": "DateTime",
  "GameLib.ts": "Game",
  "Engine3D.ts": "Engine3D",
  "PerlinNoise.ts": "PerlinNoise",
  "Network.ts": "Network",
  "ThreadLib.ts": "Thread",
  "Crypto.ts": "Crypto",
  "WindowLib.ts": "Window",
};

const libraryDefinitions = {};

function createSnippet(argsStr) {
  if (!argsStr || argsStr.trim() === "") return "()";
  const args = argsStr
    .split(",")
    .map((a) => a.trim().split(":")[0].split("=")[0].trim());
  return "(" + args.map((arg, i) => `\${${i + 1}:${arg}}`).join(", ") + ")";
}

// 1. Extract Library Members from src/lib/*.ts
const files = fs
  .readdirSync(libDir)
  .filter(
    (f) =>
      f.endsWith(".ts") &&
      !["BaseLibConverter.ts", "RequireFunctions.ts", "Utils.ts"].includes(f),
  );

files.forEach((file) => {
  const content = fs.readFileSync(path.join(libDir, file), "utf-8");
  const libName = libMap[file] || file.replace(".ts", "");
  const members = [];

  // Constants
  const constRegex = /public\s+readonly\s+([a-zA-Z0-9_$]+)\s*=/g;
  let match;
  while ((match = constRegex.exec(content))) {
    members.push({
      name: match[1],
      kind: "Constant",
      detail: `${libName}.${match[1]}`,
    });
  }

  // Methods
  const methodRegex =
    /(?:public\s+)?([a-zA-Z0-9_$]+)\s*\(([^)]*)\)\s*(?::\s*[^ {]+)?\s*{/g;
  while ((match = methodRegex.exec(content))) {
    if (["constructor", "if", "for", "while", "catch"].includes(match[1]))
      continue;

    let rawArgs = match[2].replace(/\s+/g, " ").trim();
    members.push({
      name: match[1],
      kind: "Method",
      detail: `${libName}.${match[1]}(${rawArgs})`,
      insertText: match[1] + createSnippet(rawArgs),
    });
  }
  libraryDefinitions[libName] = members;
});

// 2. Extract Global Functions from environment.ts
const envContent = fs.readFileSync(envFile, "utf-8");
const globalSymbols = [];

const declareVarRegex =
  /env\.declareVar\(\s*["']([^"']+)["']\s*,\s*(?:MK_NATIVE_FN\((?:([^)]*)\)\s*=>\s*\{|([^)]+)))/g;
let symbolMatch;
while ((symbolMatch = declareVarRegex.exec(envContent))) {
  const name = symbolMatch[1];
  if (libraryDefinitions[name]) continue;
  if (["true", "false", "null"].includes(name)) continue;

  // For environment.ts, finding exact params via regex is harder,
  // but we can at least provide () and core ones.
  let snippet = "($1)";
  if (name === "print") snippet = "($0)";
  if (name === "rand") snippet = "(${1:start}, ${2:end})";
  if (name === "len") snippet = "(${1:val})";

  globalSymbols.push({
    name: name,
    kind: "Function",
    detail: `fn ${name}(...)`,
    documentation: `Built-in global function ${name}`,
    insertText: name + snippet,
  });
}

// 3. Generate the Final TypeScript file
let tsOutput = `// AUTOMATICALLY GENERATED BY extract_libraries.js - DO NOT EDIT MANUALLY
import { CompletionItemKind, InsertTextFormat } from 'vscode-languageserver/node';

export interface SymbolMember {
  name: string;
  kind: CompletionItemKind;
  detail: string;
  documentation?: string;
  insertText?: string;
}

export interface GlobalSymbol {
  name: string;
  kind: CompletionItemKind;
  detail: string;
  documentation?: string;
  members?: SymbolMember[];
  insertText?: string;
}

`;

for (const [lib, members] of Object.entries(libraryDefinitions)) {
  tsOutput += `const ${lib.toUpperCase()}_MEMBERS: SymbolMember[] = [\n`;
  members.forEach((m) => {
    const safeDetail = m.detail.replace(/'/g, "\\'");
    const insertLine = m.insertText
      ? `, insertText: '${m.insertText.replace(/'/g, "\\'")}'`
      : "";
    tsOutput += `  { name: '${m.name}', kind: CompletionItemKind.${m.kind}, detail: '${safeDetail}'${insertLine} },\n`;
  });
  tsOutput += `];\n\n`;
}

tsOutput += `export const GLOBAL_SYMBOLS: GlobalSymbol[] = [\n`;
tsOutput += `  { name: 'let', kind: CompletionItemKind.Keyword, detail: 'let variable = value', insertText: 'let \${1:name} = \${2:value}' },\n`;
tsOutput += `  { name: 'const', kind: CompletionItemKind.Keyword, detail: 'const name = value', insertText: 'const \${1:name} = \${2:value}' },\n`;
tsOutput += `  { name: 'fn', kind: CompletionItemKind.Keyword, detail: 'Function Declaration', insertText: 'fn \${1:name}(\${2:args}) {\\n  \${0}\\n}' },\n`;
tsOutput += `  { name: 'main', kind: CompletionItemKind.Snippet, detail: 'Main Entry Point', insertText: 'fn main() {\\n  \${0}\\n}' },\n`;
tsOutput += `  { name: 'lambda', kind: CompletionItemKind.Snippet, detail: 'Lambda Expression () -> {}', insertText: '(\${1:args}) -> {\${0}}' },\n`;
tsOutput += `  { name: 'if', kind: CompletionItemKind.Keyword, detail: 'If Statement', insertText: 'if (\${1:condition}) {\\n  \${0}\\n}' },\n`;
tsOutput += `  { name: 'ife', kind: CompletionItemKind.Snippet, detail: 'If-Else Statement', insertText: 'if (\${1:condition}) {\\n  \${2}\\n} else {\\n  \${0}\\n}' },\n`;
tsOutput += `  { name: 'while', kind: CompletionItemKind.Keyword, detail: 'While Loop', insertText: 'while (\${1:condition}) {\\n  \${0}\\n}' },\n`;
tsOutput += `  { name: 'import', kind: CompletionItemKind.Keyword, detail: 'Import Library/Symbol', insertText: 'import { \${1:Symbols} } from "\${2:source}"' },\n`;
tsOutput += `  { name: 'obj', kind: CompletionItemKind.Snippet, detail: 'Object Literal', insertText: '{\\n  \${1:key}: \${2:value},\\n  \${0}\\n}' },\n`;
tsOutput += `  { name: 'true', kind: CompletionItemKind.Constant, detail: 'boolean' },\n`;
tsOutput += `  { name: 'false', kind: CompletionItemKind.Constant, detail: 'boolean' },\n`;
tsOutput += `  { name: 'null', kind: CompletionItemKind.Constant, detail: 'null' },\n`;

globalSymbols.forEach((s) => {
  tsOutput += `  { name: '${s.name}', kind: CompletionItemKind.${s.kind}, detail: '${s.detail}', documentation: '${s.documentation}', insertText: '${s.insertText}' },\n`;
});

for (const lib of Object.keys(libraryDefinitions)) {
  tsOutput += `  { name: '${lib}', kind: CompletionItemKind.Class, detail: '${lib} Library', members: ${lib.toUpperCase()}_MEMBERS },\n`;
}

tsOutput += `];\n`;

fs.writeFileSync(path.join(__dirname, "globalSymbols.ts"), tsOutput);
console.log("Successfully generated globalSymbols.ts with snippet support");
